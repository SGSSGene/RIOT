Dynamic Loader for RIOT
=======================

This is a port of the Contiki
[dynamic loader](https://github.com/contiki-os/contiki/wiki/The-dynamic-loader)
to RIOT. While usually a RIOT application is compiled together with
the OS into a single binary, this module allows put code on a running
system and execute it. This allows adding new functions to a running
system.

The trickiest part about dynamic loading are the dynamic relocations,
which are different on every cpu, and hence must be implemented for
each cpu. As an example implementation the relocations for the msp-430
is provided.

Creating Dynamic Applications
-----------------------------

The dynamic loader is able to parse an
[elf](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)
file and figure out *where* new addresses need to be written to and
*which* new addresses need to be written. 

To execute dynamic code in RIOT, the user need to provide an object
file (.o) with the code. It is the responsibility of the developer of a
dynamic application to provide an object file with at least the
*.text*, *.data*, *.bss*, *.strtab* and *.symtab* sections. When there
are some relocation in *.text* and/or *.data*, also the *.rela.text*
and/or *.data.text* need to be in the object file, which should be
ensured by the compiler/linker.

An example of a dynamic application for the msp-430 can be found in
the tests as *test_dyn_app*.

Compiling RIOT with the Elfloader
---------------------------------

To use load dynamic functions in RIOT, you need to use the *elfloader*
module in your project.

	USEMODULE += elfloader

Also if your future dynamic applications need to be able to use
functions from RIOT, or anything that has a name and is compiled into
RIOT, you need to include a special symbol table. This symbol table is
generated by a special script (also taken from the Contiki
project). For that end a C source file is generated, that is compiled
into RIOT. To stabilize the addresses in this table, RIOT needs to be
compiled several times. Please look in *test_loader* for an example.

Please note, that while compiling RIOT for dynamic loading, you need
to ensure, that every function or global variable, that will be used
by your dynamic applications, is compiled into RIOT. So e.g. if you
want to use a certain module in your dynamic applications, then that
module needs to be included into RIOT, or your dynamic application
needs to bring it along.

Loading Dynamic Applications
----------------------------

Assuming your object files lies already at a known memory location
*dyn_app*. In such case all you need to do is to call

	process_t dyn_entry;
	int status = elfloader_load(dyn_app, "dyn_main", &dyn_entry, 0);

where *"dyn_main"* is the name of the function you want the address
of. *elfloader_load(...)* will then do all the relocations and return
the address of the *"dyn_main"* symbol to &dyn\_entry. In the example
*process\_t* is the type of the *dyn\_main* symbol and the programmer
needs to ensure that it is correct. It can be e.g. a function pointer
and if it is, then the following is possible:

	int result = dyn_entry();

Which executes the function at *dyn\_entry*.

# Supporting Dynamic Loading on Other Systems

In this section we describe how to support dynamic loading on a new
system and by this explain the details of the process.

Creating a loadable object file
-------------------------------------------

The biggest challenge in running dynamic code, is that the final
memory locations of functions and other symbols are unknown at
compile/link time. Even when producing position independent (gcc
switch *-fPIC*) there may (and most probably will) be some unresolved
references in your object file. Those unresolved references need to
correspond to symbols in the kernel.

The easiest way to create an object file that meets your requirements
is to compile a single *.c* file

	${MY_CPU_SPECIFIC_GCC} -c main.c -o main.o

An example is provided in *tests/test_dyn_app*, where the resulting
object file is hexdumped into C source file, which is useful for
debugging, since that's probably the easiest way to get your
application into memory at a known position.
