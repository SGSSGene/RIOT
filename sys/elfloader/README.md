Dynamic Loader for RIOT
=======================

This is a port of the Contiki
[dynamic loader](https://github.com/contiki-os/contiki/wiki/The-dynamic-loader)
to RIOT. While usually a RIOT application is compiled together with
the OS into a single binary, this module allows put code on a running
system and execute it. This allows adding new functions to a running
system.

The trickiest part about dynamic loading are the dynamic relocations,
which are different on every cpu, and hence must be implemented for
each cpu. As an example implementation the relocations for the msp-430
is provided.

Creating Dynamic Applications
-----------------------------

The dynamic loader is able to parse an
[elf](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)
file and figure out *where* new addresses need to be written to and
*which* new addresses need to be written. 

To execute dynamic code in RIOT, the user need to provide an object
file (.o) with the code. It is the responsibility of the developer of a
dynamic application to provide an object file with at least the
*.text*, *.data*, *.bss*, *.strtab* and *.symtab* sections. When there
are some relocation in *.text* and/or *.data*, also the *.rela.text*
and/or *.data.text* need to be in the object file, which should be
ensured by the compiler/linker.

An example of a dynamic application for the msp-430 can be found in
the tests as *test_dyn_app*.

Compiling RIOT with the Elfloader
---------------------------------

To use load dynamic functions in RIOT, you need to use the *elfloader*
module in your project.

	USEMODULE += elfloader

Also if your future dynamic applications need to be able to use
functions from RIOT, or anything that has a name and is compiled into
RIOT, you need to include a special symbol table. This symbol table is
generated by a special script (also taken from the Contiki
project). For that end a C source file is generated, that is compiled
into RIOT. To stabilize the addresses in this table, RIOT needs to be
compiled several times. Please look in *test_loader* for an example.

Loading Dynamic Applications
----------------------------

Assuming your object files lies already at a known memory location
*dyn_app*. In such case all you need to do is to call

	process_t dyn_entry;
	int status = elfloader_load(dyn_app, "dyn_main", &dyn_entry, 0);

where *"dyn_main"* is the name of the function you want the address
of. *elfloader_load(...)* will then do all the relocations and return
the address of the *"dyn_main"* symbol to &dyn\_entry. In the example
*process\_t* is the type of the *dyn\_main* symbol and the programmer
needs to ensure that it is correct. It can be e.g. a function pointer
and if it is, then the following is possible:

	int result = dyn_entry();

Which executes the function at *dyn\_entry*.

